<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Maison du Savon de Marseille</title>
    <link
      rel="icon"
      href="https://media.licdn.com/dms/image/C4D03AQG4JaIgs716Cg/profile-displayphoto-shrink_200_200/0/1568528139073?e=2147483647&v=beta&t=0bqi6y3S6Foai9ZgDtcZTwM7Okk80CHV6cHjxMC4Dxs"
      type="image/x-icon"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/4.1.2/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>
  </head>
  <body>
    <h1>Maison du Savon de Marseille</h1>
    <h2>Incarca aici fisierele cu stocurile in format csv.</h2>
    <h3>
      Poti incarca oricate fisiere csv cu stocurile, atat timp cat ele respecta
      formatul extras din Smartbill.
    </h3>
    <h3>
      In functie de cate fisiere incarci, atatea coloane cu stocurile o sa ai in
      excel-urile finale.
    </h3>
    <h4>
      De ex: daca incarci 2 excel-uri "Ferdinand" si "Pitesti", in excel-ul
      final vei avea coloanele: "totalStock", "stockFerdinand" si
      "stockPitesti".
    </h4>
    <input type="file" id="fileInput" accept=".xls" multiple />
    <button id="processButton" onclick="processFiles()" disabled>
      Process Files
    </button>
    <pre id="output"></pre>
    <script>
      fileInput.addEventListener("change", () => {
        processButton.disabled = fileInput.files.length === 0;
      });
      const trimCsvFile = (data) => {
        if (data.startsWith("ROMAR COMMUNICATION INCORPORATED SRL")) {
          const lines = data.split("\n");
          return lines.slice(9, -2).join("\n");
        }
        return data;
      };

      const readXlsFile = (file) => {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: "array" });
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];
            const csv = XLSX.utils.sheet_to_csv(worksheet);
            resolve(csv);
          };
          reader.onerror = (err) => reject(err);
          reader.readAsArrayBuffer(file);
        });
      };

      const convertCsvToJson = (data) => {
        return new Promise((resolve, reject) => {
          Papa.parse(data, {
            header: true,
            complete: (results) => {
              const jsonArray = results.data.map((item) => ({
                product: item.Produs,
                barcode: item.Cod,
                finalStock: Number(item["Stoc final"]),
              }));
              resolve(jsonArray);
            },
            error: (err) => reject(err),
          });
        });
      };

      const mergeJsons = (jsonArrays, fileNames) => {
        const mergedData = jsonArrays.reduce((acc, data, index) => {
          const key = `stock${fileNames[index]}`;
          data.forEach((item) => {
            const { product, barcode, finalStock } = item;
            const uniqueKey = `${product}-${barcode}`;
            if (!acc[uniqueKey]) {
              acc[uniqueKey] = {
                product,
                barcode,
                totalStock: 0,
              };
              jsonArrays.forEach((_, i) => {
                acc[uniqueKey][`stock${fileNames[i]}`] = 0;
              });
            }
            acc[uniqueKey][key] = finalStock;
            acc[uniqueKey].totalStock += finalStock;
          });
          return acc;
        }, {});

        return Object.values(mergedData);
      };

      const saveToXls = (data, fileName, fileNames) => {
        const fields = [
          { label: "Produs", value: "product" },
          { label: "Cod de Bare", value: "barcode" },
        ];
        fileNames.forEach((name) => {
          fields.push({
            label: `Stoc ${name.slice(0, -4)}`,
            value: `stock${name}`,
          });
        });
        fields.push({ label: "Stoc Total", value: "totalStock" });

        // // Format the barcode values as a formula to force Excel to treat them as text
        // const modifiedData = data.map((item) => ({
        //   ...item,
        //   barcode: `="${item.barcode}"`,
        // }));

        // Convert the data to a worksheet
        const worksheetData = data.map((item) =>
          fields.map((field) => item[field.value])
        );
        const worksheet = XLSX.utils.aoa_to_sheet([
          fields.map((field) => field.label),
          ...worksheetData,
        ]);

        // Create a new workbook and append the worksheet
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, "Stoc total");

        // Define the range for the table
        const range = XLSX.utils.decode_range(worksheet["!ref"]);
        const tableRange = XLSX.utils.encode_range(range);

        // Add table properties to the worksheet
        worksheet["!autofilter"] = { ref: tableRange };

        // Write the workbook to a binary string
        const workbookBinary = XLSX.write(workbook, {
          bookType: "xls",
          type: "binary",
        });

        const s2ab = (s) => {
          const buf = new ArrayBuffer(s.length);
          const view = new Uint8Array(buf);
          for (let i = 0; i < s.length; i++) {
            view[i] = s.charCodeAt(i) & 0xff;
          }
          return buf;
        };

        // Create a Blob from the binary string
        const blob = new Blob([s2ab(workbookBinary)], {
          type: "application/octet-stream",
        });

        // Create a download link and trigger the download
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = `${fileName}.xls`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      };

      const filterByProductPrefix = (data, prefix) => {
        return data.filter((item) => item.product.startsWith(prefix));
      };

      const getCurrentFormattedDate = () => {
        const date = new Date();
        const day = String(date.getDate()).padStart(2, "0");
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const year = date.getFullYear();
        return `${day}-${month}-${year}`;
      };
      let alertShown = false;
      const processFiles = async () => {
        const files = fileInput.files;
        const fileNames = Array.from(files).map((file) => file.name);
        const jsonArrays = await Promise.all(
          Array.from(files).map(async (file) => {
            const csv = await readXlsFile(file);
            if (!csv.startsWith("ROMAR COMMUNICATION")) {
              if (!alertShown) {
                alert("Aceste fisiere nu pot fi procesate.");
                alertShown = true;
                throw new Error(
                  `File ${file.name} does not start with "ROMAR COMMUNICATION"`
                );
              }
            }
            const trimmedCsv = trimCsvFile(csv);
            return convertCsvToJson(trimmedCsv);
          })
        );
        const mergedData = mergeJsons(jsonArrays, fileNames);
        const prefixes = ["C&D", "FAC", "LPN", "PDS"];
        const filteredData = prefixes.map((prefix) =>
          filterByProductPrefix(mergedData, prefix)
        );

        saveToXls(
          mergedData,
          `StocTotal-${getCurrentFormattedDate()}`,
          fileNames
        );
        prefixes.forEach((prefix, index) => {
          saveToXls(
            filteredData[index],
            `Stoc${prefix}-${getCurrentFormattedDate()}`,
            fileNames
          );
        });
      };
    </script>
  </body>
</html>
